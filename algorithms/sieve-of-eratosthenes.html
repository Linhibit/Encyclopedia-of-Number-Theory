<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>埃拉托斯特尼筛法 - 数论百科</title>
    <link rel="stylesheet" href="../style.css">
    
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            }
        };
    </script>
    
    <script 
        id="MathJax-script" 
        async 
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</head>

<body>
    <div class="article-container" 
         style="max-width: 800px; 
                margin: 40px auto; 
                padding: 20px;">
        
        <nav>
            <a href="../index.html" class="back-home" aria-label="返回首页">
                <svg class="icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
                </svg>
                返回首页
            </a>
        </nav>
        
        <header>
            <h1>埃拉托斯特尼筛法 (Sieve of Eratosthenes)</h1>
        </header>

        <section class="algorithm-box" 
                 style="border-left: 5px solid #2196F3; 
                        background: #f8fdff; 
                        padding: 20px; 
                        margin: 20px 0;">
            
            <strong>算法原理：</strong>
            <p>
                埃拉托斯特尼筛法是一种简单且高效的素数筛选算法，用于找出不超过某个整数 $n$ 的所有素数。
                其基本思想是从小到大遍历每个数，如果当前数是素数，则将其所有倍数标记为合数。
            </p>
            
            <p>
                该算法的时间复杂度为 $O(n \log \log n)$，空间复杂度为 $O(n)$。
            </p>
        </section>

        <section class="algorithm">
            <h3>算法步骤：</h3>
            
            <ol style="line-height: 1.6;">
                <li>
                    <strong>初始化：</strong>
                    创建一个长度为 $n+1$ 的布尔数组 <code>isPrime</code>，初始时将所有元素设为 <code>true</code>。
                    将 <code>isPrime[0]</code> 和 <code>isPrime[1]</code> 设为 <code>false</code>（0和1不是素数）。
                </li>
                <li>
                    <strong>筛选：</strong>
                    从 $p = 2$ 开始，遍历到 $\sqrt{n}$：
                    <ul>
                        <li>如果 <code>isPrime[p]</code> 为 <code>true</code>，则 $p$ 是素数。</li>
                        <li>
                            将 $p$ 的所有倍数（从 $p^2$ 开始，到 $n$ 为止）标记为合数，
                            即设 <code>isPrime[k] = false</code>（其中 $k = p^2, p^2+p, p^2+2p, \dots$）。
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>输出：</strong>
                    遍历完成后，所有 <code>isPrime[i] = true</code> 的 $i$ 都是素数。
                </li>
            </ol>
            
            <div style="background: #f0f8ff; padding: 15px; margin: 15px 0; border-radius: 5px;">
                <strong>优化说明：</strong>
                <ul>
                    <li>
                        <strong>从 $p^2$ 开始标记：</strong>
                        因为比 $p^2$ 小的 $p$ 的倍数（如 $2p, 3p, \dots, (p-1)p$）已经被更小的素数标记过了。
                    </li>
                    <li>
                        <strong>只需遍历到 $\sqrt{n}$：</strong>
                        如果 $n$ 有一个大于 $\sqrt{n}$ 的因子，那么它必然有一个小于 $\sqrt{n}$ 的对应因子，
                        因此在遍历到 $\sqrt{n}$ 时，所有合数都已经被标记了。
                    </li>
                </ul>
            </div>
        </section>

        <section class="code-example" 
                 style="background: #f5f5f5; 
                        padding: 20px; 
                        margin: 20px 0; 
                        border-radius: 5px;">
            
            <h3>代码示例 (JavaScript)：</h3>
            
            <pre style="background: #2d2d2d; 
                        color: #f8f8f2; 
                        padding: 15px; 
                        border-radius: 5px; 
                        overflow-x: auto;">
<code>// 基础版本
function sieveOfEratosthenes(n) {
    // 创建布尔数组，初始都为true
    const isPrime = new Array(n + 1).fill(true);
    isPrime[0] = false;
    isPrime[1] = false;
    
    // 只需筛选到 sqrt(n)
    const limit = Math.sqrt(n);
    for (let p = 2; p <= limit; p++) {
        // 如果p是素数
        if (isPrime[p]) {
            // 从p*p开始，标记p的倍数为合数
            for (let multiple = p * p; multiple <= n; multiple += p) {
                isPrime[multiple] = false;
            }
        }
    }
    
    // 收集所有素数
    const primes = [];
    for (let i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push(i);
        }
    }
    
    return primes;
}

// 优化版本：只考虑奇数，减少内存和时间
function sieveOptimized(n) {
    if (n < 2) return [];
    
    const size = Math.floor((n - 1) / 2);
    const isPrime = new Array(size).fill(true);
    
    // 筛选过程
    const limit = Math.floor((Math.sqrt(n) - 1) / 2);
    for (let i = 0; i <= limit; i++) {
        if (isPrime[i]) {
            const p = 2 * i + 3;  // 对应的素数
            // 从p*p开始标记
            const start = 2 * i * i + 6 * i + 3;
            for (let j = start; j < size; j += p) {
                isPrime[j] = false;
            }
        }
    }
    
    // 收集素数，包括2和所有奇数素数
    const primes = [2];
    for (let i = 0; i < size; i++) {
        if (isPrime[i]) {
            primes.push(2 * i + 3);
        }
    }
    
    return primes;
}

// 示例使用
console.log(sieveOfEratosthenes(30));  
// 输出: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

console.log(sieveOptimized(30));
// 输出: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

// 性能测试
console.time('基础筛法');
sieveOfEratosthenes(1000000);
console.timeEnd('基础筛法');

console.time('优化筛法');
sieveOptimized(1000000);
console.timeEnd('优化筛法');</code>
            </pre>
            
            <p style="margin-top: 15px;">
                <strong>算法复杂度分析：</strong>
                外层循环遍历 $2$ 到 $\sqrt{n}$，内层循环标记倍数。总标记次数约为：
                $$
                \sum_{p \leq \sqrt{n}} \frac{n}{p} \approx n \sum_{p \leq \sqrt{n}} \frac{1}{p} \approx n \log \log n
                $$
                因此时间复杂度为 $O(n \log \log n)$。
            </p>
        </section>

        <section class="example" 
                 style="background: #f9f9f9; 
                        padding: 20px; 
                        margin: 20px 0; 
                        border-radius: 5px;">
            
            <h3>示例：筛选 30 以内的素数</h3>
            
            <p>以下表格展示了埃拉托斯特尼筛法的执行过程：</p>
            
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <thead>
                    <tr style="background: #e0e0e0;">
                        <th style="padding: 8px; border: 1px solid #ccc;">步骤</th>
                        <th style="padding: 8px; border: 1px solid #ccc;">当前素数 $p$</th>
                        <th style="padding: 8px; border: 1px solid #ccc;">标记的倍数</th>
                        <th style="padding: 8px; border: 1px solid #ccc;">剩余的候选数</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ccc;">初始化</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">-</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">-</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">2-30</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ccc;">1</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">2</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">4,6,8,10,12,14,16,18,20,22,24,26,28,30</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">2,3,5,7,9,11,13,15,17,19,21,23,25,27,29</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ccc;">2</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">3</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">9,15,21,27</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">2,3,5,7,11,13,17,19,23,25,29</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ccc;">3</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">5</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">25</td>
                        <td style="padding: 8px; border: 1px solid #ccc;">2,3,5,7,11,13,17,19,23,29</td>
                    </tr>
                </tbody>
            </table>
            
            <p>最终得到 30 以内的素数：2, 3, 5, 7, 11, 13, 17, 19, 23, 29。</p>
        </section>

        <section class="variants" 
                 style="background: #f0f8ff; 
                        padding: 20px; 
                        margin: 20px 0; 
                        border-radius: 5px;">
            
            <h3>变体与改进：</h3>
            
            <ol style="line-height: 1.6;">
                <li>
                    <strong>分段筛法：</strong>
                    当 $n$ 非常大时，可以将区间分段，每次只筛选一段，以减少内存使用。
                    适用于需要生成极大范围内的素数的情况。
                </li>
                <li>
                    <strong>线性筛法（欧拉筛）：</strong>
                    通过确保每个合数只被其最小质因子标记一次，时间复杂度可降至 $O(n)$，
                    但需要更多的内存来存储素数列表。
                </li>
                <li>
                    <strong>位集优化：</strong>
                    使用位集（bitset）来表示布尔数组，可以将内存使用减少到原来的 1/8。
                </li>
                <li>
                    <strong>仅考虑奇数：</strong>
                    除了 2 以外，所有素数都是奇数，因此可以只考虑奇数候选数，
                    将内存和时间减半。
                </li>
            </ol>
        </section>

        <section class="notes" 
                 style="background: #fffde7; 
                        padding: 15px; 
                        margin: 20px 0; 
                        border-left: 3px solid #ffd600;">
            
            <h4>📝 历史背景：</h4>
            <p>
                埃拉托斯特尼筛法以古希腊数学家<strong>埃拉托斯特尼</strong>（Eratosthenes，公元前276-194年）命名。
                他是一位多才多艺的学者，不仅发明了这种素数筛选算法，还首次相当精确地计算了地球的周长。
            </p>
            
            <p>
                该算法已有两千多年的历史，至今仍在许多场合中被使用，因为它简单且高效。
                虽然存在更高效的素数筛选算法（如欧拉筛），但埃氏筛因其实现简单而广受欢迎。
            </p>
        </section>
    </div>
</body>
</html>